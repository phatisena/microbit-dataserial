{"entries":[{"timestamp":1737880572148,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" id=\"wrTVthT``dr_4{f5MDuf\" x=\"20\" y=\"20"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start"],[0,"\"></"]],"start1":12,"start2":12,"length1":135,"length2":62},{"diffs":[[0,"</block>"],[1,"\n  "],[0,"<block t"]],"start1":72,"start2":72,"length1":16,"length2":19},{"diffs":[[0,"ver\""],[-1," id=\"qKv1IBNXwe}Irs#78ud.\" x=\"225\" y=\"20\""],[0,"></b"]],"start1":107,"start2":107,"length1":49,"length2":8},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"\n"],[-1,"//%block=\"DataSerial\"\n//%color=\"#44d4ca\"\n//%icon=\"\\uf187\"\nnamespace dataserial {\n\n    let cidk: { [key: string]: number } = {}\n\n    //%block=\"$name\"\n    //%blockId=dataserial_indexkeyshadow\n    //%blockHidden=true shim=TD_ID\n    //%name.fieldEditor=\"autocomplete\" name.fieldOptions.decompileLiterals=true\n    //%name.fieldOptions.key=\"dataserialindexkey\"\n    export function _indexKeyShadow(name: string) {\n        return name\n    }\n\n    //%blockid=dataserial_startindexkey\n    //%block=\"set index in $name by $num\"\n    //%name.shadow=\"dataserial_indexkeyshadow\" name.defl=\"myIdxKey\"\n    //%group=\"index key\"\n    //%weight=10\n    export function setIdxKey(name: string, num: number) {\n        cidk[name] = num\n    }\n\n    //%blockid=dataserial_getindexkey\n    //%block=\"get $name from index key\"\n    //%name.shadow=\"dataserial_indexkeyshadow\" name.defl=\"myIdxKey\"\n    //%group=\"index key\"\n    //%weight=5\n    export function getIdxKey(name: string) {\n        return cidk[name]\n    }\n\n    //%blockid=dataserial_writevalue\n    //%block=\"write $strval\"\n    //%group=\"write and read\"\n    //%weight=10\n    export function write(strval: string) {\n        let oval = \"\", curc = \"\"\n        for (let i = 0; i < strval.length; i++) {\n            curc = strval.charAt(i)\n            if (\"\\\\|\".includes(curc)) {\n                oval = \"\" + oval + \"\\\\\"\n            }\n            oval = \"\" + oval + curc\n        }\n        oval = \"\" + oval + \"|\"\n        return oval\n    }\n\n    //%blockid=dataserial_readvalue\n    //%block=\"read $txt from idx key $name\"\n    //%name.shadow=\"dataserial_indexkeyshadow\" name.defl=\"myIdxKey\"\n    //%group=\"write and read\"\n    //%weight=5\n    export function read(txt: string, name: string) {\n        if (cidk[name] == null) return \"\";\n        let idx = cidk[name]\n        let oval = \"\", curc = \"\"\n        while (idx < txt.length) {\n            curc = txt.charAt(idx)\n            if (\"|\".includes(curc)) {\n                break\n            } else if (\"\\\\\".includes(curc)) {\n                idx += 1\n                curc = txt.charAt(idx)\n            }\n            oval = \"\" + oval + curc\n            idx += 1\n        }\n        idx += 1, cidk[name] = idx\n        return oval\n    }\n\n    function checkStrf2e(txt: string, fchr: string, lchr: string) {\n        if (txt.substr(0, fchr.length) === fchr && txt.substr(Math.abs(txt.length - lchr.length), lchr.length) === lchr) return true;\n        return false;\n    }\n\n    //%blockid=dataserial_savestrarray\n    //%block=\"save string array $inputStrArr\"\n    //%group=\"array in string\"\n    //%weight=10\n    export function saveStrArr(inputStrArr: string[]) {\n        let outputStr = \"\"\n        outputStr = \"\" + outputStr + write(\"[str<\")\n        let cval = \"\"\n        let count = 1\n        for (let val of inputStrArr) {\n            if (cval.isEmpty()) {\n                cval = val\n            } else {\n                if (cval == val) {\n                    count += 1\n                } else {\n                    outputStr = \"\" + outputStr + write(count.toString())\n                    outputStr = \"\" + outputStr + write(cval)\n                    cval = val\n                    count = 1\n                }\n            }\n        }\n        outputStr = \"\" + outputStr + write(count.toString())\n        outputStr = \"\" + outputStr + write(cval)\n        outputStr = \"\" + outputStr + write(\">str]\")\n        return outputStr\n    }\n\n    //%blockid=dataserial_loadstrarray\n    //%block=\"load string array $inputStr\"\n    //%group=\"array in string\"\n    //%weight=8\n    export function loadStrArr(inputStr: string) {\n        let outputStrArr: string[] = []\n        setIdxKey(\"_StrArrData\", 0)\n        let val = read(inputStr, \"_StrArrData\")\n        if (!(checkStrf2e(val, \"[\", \"<\"))) return [];\n        let count = 0, countstr = \"\"\n        while (getIdxKey(\"_StrArrData\") < inputStr.length) {\n            if (count <= 0) {\n                countstr = read(inputStr, \"_StrArrData\")\n                if (checkStrf2e(countstr, \">\", \"]\")) break;\n                count = parseInt(countstr)\n                val = read(inputStr, \"_StrArrData\")\n            }\n            while (count > 0) {\n                count -= 1\n                outputStrArr.push(val)\n            }\n        }\n        return outputStrArr\n    }\n\n    //%blockid=dataserial_savestrtablearray\n    //%block=\"save string table array $inputStrArr\"\n    //%inputStrArr.shadow=variables_get inputStrArr.defl=StringTableArray\n    //%group=\"array in string\"\n    //%weight=6\n    export function saveStrTableArr(inputStrArr: string[][]) {\n        let outputStr = \"\"\n        outputStr = \"\" + outputStr + write(\"[str<\")\n        let cval = \"\"\n        let count = 1, nv = 0\n        for (let n = 0; n < inputStrArr.length; n++) {\n            for (let val of inputStrArr[n]) {\n                if (cval.isEmpty()) {\n                    cval = val\n                } else {\n                    if (cval == val) {\n                        count += 1\n                    } else if (n !== nv) { nv = n; count = 1; cval = val } else {\n                        outputStr = \"\" + outputStr + write(count.toString())\n                        outputStr = \"\" + outputStr + write(cval)\n                        cval = val\n                        count = 1\n                    }\n                }\n            }\n            outputStr = \"\" + outputStr + write(count.toString())\n            outputStr = \"\" + outputStr + write(cval)\n            if (n < inputStrArr.length - 1) outputStr = \"\" + outputStr + write(\">]str[<\");\n        }\n        outputStr = \"\" + outputStr + write(\">str]\")\n        return outputStr\n    }\n\n    //%blockid=dataserial_loadstrarray\n    //%block=\"load string table array $inputStr\"\n    //%group=\"array in string\"\n    //%weight=4\n    export function loadStrTableArr(inputStr: string) {\n        let outputStrArr: string[][] = []\n        setIdxKey(\"_StrArrData\", 0)\n        let val = read(inputStr, \"_StrArrData\")\n        if (!(checkStrf2e(val, \"[\", \"<\"))) return [];\n        outputStrArr.push([])\n        let count = 0, countstr = \"\", cidx = outputStrArr.length - 1\n        while (getIdxKey(\"_StrArrData\") < inputStr.length) {\n            if (count <= 0) {\n                countstr = read(inputStr, \"_StrArrData\")\n                if (checkStrf2e(countstr, \">]\", \"[<\")) {\n                    outputStrArr.push([])\n                    cidx = outputStrArr.length - 1\n                } else if (checkStrf2e(countstr, \">\", \"]\")) { break; } else {\n                    count = parseInt(countstr)\n                    val = read(inputStr, \"_StrArrData\")\n                }\n            }\n            while (count > 0) {\n                count -= 1\n                outputStrArr[cidx].push(val)\n            }\n        }\n        return outputStrArr\n    }\n}\n"]],"start1":0,"start2":0,"length1":6724,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"   \""],[-1,"testFiles\": [\n        \"test.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\""],[1,"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":243,"start2":243,"length1":76,"length2":31}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1737880572147,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"microbit-dataserial\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1737880632664}